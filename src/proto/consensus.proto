// Copyright (c) Shubham Mishra. All rights reserved.
// Licensed under the MIT License.

syntax = "proto3";

package proto.consensus;
import "execution.proto";
import "client.proto";

message ProtoNameWithSignature {
    string name = 1;
    bytes sig = 2;
}
message ProtoQuorumCertificate {
    bytes digest = 1;                        // Hash of certifying block
    uint64 n = 2;                            // Sequence number of certifying block
    repeated ProtoNameWithSignature sig = 3; // signer node --> Signature mapping;
                                             // but represented as array of tuples, so that protobuf doesn't reorder them
    uint64 view = 4;
}

// Empty type
message DefferedSignature { }

message ProtoViewChange {
    uint64 view = 1;
    uint64 config_num = 2;
    ProtoFork fork = 3;
    ProtoQuorumCertificate fork_last_qc = 4;
    uint64 fork_last_n = 5;
    bytes fork_sig = 6;

    // The signature needs to be agnostic of how much of the prefix is sent over.
    // Signature is over H(last_block) || H(fork_last_qc) || view || config_num || fork_last_n
}

message ProtoForkValidation {
    uint64 vc_view = 1;
    uint64 vc_config_num = 2;
  
    repeated bytes block_hashes = 3;
    uint64 fork_last_n = 4;
    ProtoQuorumCertificate fork_last_qc = 5;
    uint64 fork_last_view = 6;
    uint64 fork_last_config_num = 7;

    bytes vc_sig = 8;
    string sender = 9;

}

message ProtoTransactionList {
    repeated proto.execution.ProtoTransaction tx_list = 1;
}

message ProtoBlock {
    repeated proto.execution.ProtoTransaction tx_list = 1;
    // oneof tx {
        // ProtoTransactionList tx_list = 1;    // list of transactions
        // bytes tx_list_hash = 11;             // hash of the list of transactions  
    // }
    uint64 n = 2;                            // sequence number; u64 => don't worry about wrap-around.
    bytes parent = 3;                        // Hash chain parent
    uint64 view = 4;                         // proposer must be Leader(view)
    repeated ProtoQuorumCertificate qc = 5;  // List of quorum certificates attached to this block.
    repeated ProtoForkValidation fork_validation = 6; // List of view change messages. To check if this block is coming from a suitable fork.
    bool view_is_stable = 7;

    uint64 config_num = 8;
    oneof sig {
        DefferedSignature no_sig = 9;
        bytes proposer_sig = 10;
    }
}

message HalfSerializedBlock {
    uint64 n = 1;
    uint64 view = 2;
    bool view_is_stable = 3;
    uint64 config_num = 4;
    bytes serialized_body = 5;      // Format: signature || parent_hash || serialized body
}

// This is different from the logical view of a fork with fields `last` and `last_qc`.
message ProtoFork {
    repeated HalfSerializedBlock serialized_blocks = 1;
}

// Append Block (eliminates forks from dissemination)
// FIXME: support repeated blocks everywhere
message ProtoAppendBlocks {
    repeated HalfSerializedBlock serialized_blocks = 1;
    uint64 commit_index = 2;
    uint64 view = 3;
    bool view_is_stable = 4;
    uint64 config_num = 6;
    bool is_backfill_response = 7;
}

// Append Block with Lane for backfill requests
message ProtoAppendBlockLane {
    string name = 1;            // Name identifies lane
    ProtoAppendBlocks ab = 2;    // AppendBlock request
}

// Block Acknowledgement for constructing PoA
// QUESTION: DO we need a sig array here or just one?
message ProtoBlockAck {
    bytes digest = 1;       // Hash of block
    uint64 n = 2;           // Sequence Number of block
    bytes lane = 3;         // Proposer Signature to ID lane
    bytes sig = 4;          // My Signature for voting
}

// PoA (CAR) for a block with a digest
message ProtoBlockCAR {
    bytes digest = 1;       // Hash of Block
    // QUESTION: Do we need a parent link here too?
    uint64 n = 2;           // Sequence Number
    repeated ProtoNameWithSignature sig = 3; // signer node -> Signature mapping
    uint64 view = 4;        // QUESTION: Do we actually need a view number here??
    string origin_node = 5; // Node that originally accepted the client requests (for proxy pattern)
}

// Tip Cut proposal of up to N CARs
// Will be wrapped in an AppendEntries for view info
message ProtoTipCut {
    bytes digest = 1;       // Digest of tip cut to use in commit log
    bytes parent = 2;       // Digest of parent
    repeated ProtoBlockCAR tips = 3;  // Tip Cut of up to N CARs (which give digest, seq num, lane sig, etc.)
}

// AppendEntries
// either Fork or TipCut
message ProtoAppendEntries {
    oneof entry {
        ProtoFork fork = 1;
        ProtoTipCut tipcut = 8;
    }
    uint64 commit_index = 2;
    uint64 view = 4;
    bool view_is_stable = 5;
    uint64 config_num = 6;
    bool is_backfill_response = 7;
}

// Array of signatures
message ProtoSignatureArrayEntry {
    uint64 n = 1;                                // Sequence number
    bytes sig = 2;
}

// Vote for a Fork or TipCut 
message ProtoVote {
    repeated ProtoSignatureArrayEntry sig_array = 1;
    bytes digest = 2;       // Digest of either fork or tip cut
    uint64 n = 3;
    uint64 view = 4;
    uint64 config_num = 5;
}

// Execution Results for DAG Proxy Pattern
// Leader sends this to origin nodes so they can respond to their local clients
message ProtoExecutionResults {
    bytes block_hash = 1;                               // Hash of block that was executed
    uint64 block_n = 2;                                 // Sequence number of executed block (for client receipts)
    repeated proto.execution.ProtoTransactionResult results = 3;  // Execution results for each transaction
    string origin_node = 4;                             // Target node that should receive these results
}

// Byzantine Responses forwarding for DAG Proxy Pattern
// Leader sends this to origin nodes so they can attach byz responses to local receipts
message ProtoByzResults {
    bytes block_hash = 1;                               // Hash of block that was byz-committed
    uint64 block_n = 2;                                 // Sequence number of block
    repeated proto.client.ProtoByzResponse responses = 3; // Byz responses for each tx
    string origin_node = 4;                             // Target node that should receive these responses
}
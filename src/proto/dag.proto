// DAG Dissemination Message Types

syntax = "proto3";

package proto.dag;
import "execution.proto";
import "consensus.proto";

// Append Block (eliminates forks from dissemination)
// Questions: Do view_is_stable and commit_index matter?
message ProtoAppendBlock {
    proto.consensus.HalfSerializedBlock block = 1;
    uint64 commit_index = 2;
    uint64 view = 3;
    bool view_is_stable = 4;
    uint64 config_num = 6;
    bool is_backfill_response = 7;
}

// Block Acknowledgement for constructing PoA
// Question: DO we need a sig array here or just one?
message ProtoBlockAck {
    bytes digest = 1;       // Hash of block
    uint64 n = 2;           // Sequence Number of block
    bytes lane = 3;         // Proposer Signature to ID lane
    bytes sig = 4;          // My Signature for voting
}

// TODO: Figure out if CARs should be done on Blocks or Forks/how Forks apply here
// PoA (CAR) for a block with a digest
message ProtoBlockCAR {
    bytes digest = 1;       // Hash of Block
    // QUESTION: Do we need a parent link here too?
    uint64 n = 2;           // Sequence Number
    repeated proto.consensus.ProtoNameWithSignature sig = 3; // signer node -> Signature mapping
    uint64 view = 4;        // QUESTION: Do we actually need a view number here??
}

// Tip Cut proposal of up to N CARs
message ProtoTipCut {
    repeated ProtoBlockCAR tip_cut = 1;  // Tip Cut of up to N CARs (which give digest, seq num, lane sig, etc.)
    uint64 commit_index = 2;
    uint64 view = 3;
    bool view_is_stable = 4;
    uint64 config_num = 5;
    bool is_backfill_response = 6;      // Do we need this??
}

// Similar to ProtoVote, but vote on tip_cut
message ProtoTipCutVote {
    repeated proto.consensus.ProtoSignatureArrayEntry sig_array = 1;
    bytes tc_digest = 2;        // Digest of Tip Cut
    uint64 view = 4;
    uint64 config_num = 5;
}